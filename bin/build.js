import { exec as execSync } from 'child_process';
import esbuild from 'esbuild';
import { writeFile, readFile } from 'fs/promises';
import { promisify } from 'util';

const exec = promisify(execSync);

/**
 * Builds the client and server files into production-ready JS files.
 */
async function build() {
	return new Promise(async (resolve, reject) => {
		try {
			for (let i = 0; i < contexts.length; i++) {
				const context = contexts[i];
				const entryPath = `${srcPath}/${context.name}/index.ts`;
				const outputPath = `${distPath}/${context.name}.js`;

				const watchPlugin = {
					name: 'watch-plugin',
					setup(build) {
						let count = 0;
						build.onEnd((result) => {
							const status = count === 0 ? 'built' : 'rebuilt';
							const message =
								result.errors.length === 0 ? `files ${status} successfully.` : `${status} with issues.`;
							console.log(`${context.name.charAt(0).toUpperCase() + context.name.slice(1)} ${message}`);
							count++;

							if (i + 1 >= contexts.length) {
								generateFxManifest();
								!production && console.log('\nWatching for file changes...');
							}
						});
					},
				};

				const options = {
					bundle: true,
					entryPoints: [entryPath],
					outfile: outputPath,
					keepNames: true,
					dropLabels: production ? ['DEV'] : undefined,
					legalComments: 'inline',
					...context.buildOptions,
				};

				const ctx = await esbuild.context({ ...options, plugins: [watchPlugin] });
				await ctx.watch();

				if (production) await ctx.dispose();
			}
			resolve();
		} catch {
			reject();
		}
	});
}

/**
 * Generates the fxmanifest.lua file based of package.json and fxmanifest.json
 */
async function generateFxManifest() {
	const packageJson = await readJSON('./package.json');
	const fxmanifestJson = await readJSON('./fxmanifest.json');

	let fxManifest =
		'-- @@@ This file is automatically generated during build @@@\n' +
		'-- @@@ Make changes in the fxmanifest.json / package.json files @@@\n\n' +
		`author '${packageJson.author}'\n` +
		`description '${packageJson.description}'\n` +
		`version '${packageJson.version}'\n\n`;

	const keys = Object.keys(fxmanifestJson);
	keys.forEach((key) => {
		const value = fxmanifestJson[key];
		if (Array.isArray(value)) {
			fxManifest += `${key} {\n`;
			value.forEach((item, index) => {
				fxManifest += index === value.length - 1 ? `\t'${item}'\n` : `'${item}',\n`;
			});
			fxManifest += '}\n';
		} else {
			fxManifest += `${key} '${value}'\n`;
		}
	});

	writeFile('fxmanifest.lua', fxManifest);

	// FXServer won't attempt to rebuild files by writing this.
	writeFile(
		'.yarn.installed',
		new Date().toLocaleString('en-US', {
			timeZone: 'UTC',
			timeStyle: 'long',
			dateStyle: 'full',
		})
	);
}

/**
 * Reads a json and file and parses its data.
 * @param {string} filePath
 * @returns
 */
async function readJSON(filePath) {
	try {
		const fileContent = await readFile(filePath, 'utf8');
		return JSON.parse(fileContent);
	} catch (error) {
		console.error('Error reading or parsing the file:', error);
		throw error;
	}
}

const srcPath = 'src';
const distPath = 'dist';

const production = process.argv.findIndex((argItem) => argItem === '--mode=production') >= 0;

const contexts = [
	{
		name: 'server',
		buildOptions: {
			platform: 'node',
			target: ['node16'],
			format: 'cjs',
		},
	},
	{
		name: 'client',
		buildOptions: {
			platform: 'browser',
			target: ['es2021'],
			format: 'cjs',
		},
	},
];

await exec('node ./bin/clear.js');

await build();

console.log('\nGenerating types...\n');
await exec('node ./bin/types.js');
