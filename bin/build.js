import { exec as execSync } from 'child_process';
import esbuild from 'esbuild';
import { writeFile, readFile } from 'fs/promises';
import { promisify } from 'util';

const exec = promisify(execSync);

/**
 * Builds the client and server files into production-ready JS files.
 */
async function build() {
    return new Promise(async (resolve, reject) => {
        try {
            for (let i = 0; i < contexts.length; i++) {
                const context = contexts[i];
                const entryPath = `${srcPath}/${context.name}/index.ts`;
                const outputPath = `${distPath}/${context.name}.js`;

                const watchPlugin = {
                    name: 'watch-plugin',
                    setup(build) {
                        let count = 0;
                        build.onEnd((result) => {
                            const status = count === 0 ? 'built' : 'rebuilt';
                            const message =
                                result.errors.length === 0 ? `files ${status} successfully.` : `${status} failed.`;
                            console.log(`${context.name.charAt(0).toUpperCase() + context.name.slice(1)} ${message}`);
                            count++;

                            if (i + 1 >= contexts.length) {
                                generateFxManifest();
                                !production && console.log('\nWatching for file changes...');
                            }
                        });
                    },
                };

                const options = {
                    bundle: true,
                    entryPoints: [entryPath],
                    outfile: outputPath,
                    keepNames: true,
                    dropLabels: production ? ['DEV'] : undefined,
                    legalComments: 'inline',
                    ...context.buildOptions,
                };

                const ctx = await esbuild.context({ ...options, plugins: [watchPlugin] });
                await ctx.watch();

                if (production) await ctx.dispose();
            }
            resolve();
        } catch {
            reject();
        }
    });
}

/**
 * Generates the fxmanifest.lua file based of package.json and fxmanifest.json
 */
async function generateFxManifest() {
    const packageJson = await readJSON('./package.json');
    const fxmanifestJson = await readJSON('./fxmanifest.json');

    let fxManifest =
        '-- @@@ This file is automatically generated during build @@@\n' +
        '-- @@@ Make changes in the fxmanifest.json / package.json files @@@\n\n' +
        `author '${packageJson.author}'\n` +
        `description '${packageJson.description}'\n` +
        `version '${packageJson.version}'\n\n`;

    const keys = Object.keys(fxmanifestJson);
    keys.forEach((key) => {
        const value = fxmanifestJson[key];
        if (Array.isArray(value)) {
            fxManifest += `${key} {\n`;
            value.forEach((item, index) => {
                fxManifest += `\t'${item}'${index === value.length - 1 ? '\n' : ',\n'}`;
            });
            fxManifest += '}\n';
        } else if (typeof value === 'object' && value !== null) {
            Object.entries(value).forEach(([subKey, subValue]) => {
                fxManifest += `${key} '${subKey}' {\n`;
                if (typeof subValue === 'object') {
                    Object.entries(subValue).forEach(([innerKey, innerValue]) => {
                        fxManifest += `\t${innerKey} = '${innerValue}'\n`;
                    });
                } else {
                    fxManifest += `\t${subKey} = '${subValue}'\n`;
                }
                fxManifest += '}\n';
            });
        } else {
            fxManifest += `${key} '${value}'\n`;
        }
    });

    await writeFile('fxmanifest.lua', fxManifest);

    // FXServer won't attempt to rebuild files by writing this.
    await writeFile(
        '.yarn.installed',
        new Date().toLocaleString('en-US', {
            timeZone: 'UTC',
            timeStyle: 'long',
            dateStyle: 'full',
        })
    );
}

/**
 * Reads a json file and parses the content.
 * @param {string} filePath
 * @returns
 */
async function readJSON(filePath) {
    try {
        const fileContent = await readFile(filePath, 'utf8');
        return JSON.parse(fileContent);
    } catch (error) {
        console.error('Error reading or parsing the file:', error);
        throw error;
    }
}

const srcPath = 'src';
const distPath = 'dist';

const production = process.argv.findIndex((argItem) => argItem === '--mode=production') >= 0;

/**
 * Building options of each target build.
 */
const contexts = [
    {
        name: 'server',
        buildOptions: {
            platform: 'node',
            target: ['node16'],
            format: 'cjs',
        },
    },
    {
        name: 'client',
        buildOptions: {
            platform: 'browser',
            target: ['es2021'],
            format: 'cjs',
        },
    },
];

await exec('node ./bin/clear.js');

await build();

if (production) {
    console.log('\nGenerating types...\n');
    await exec('node ./bin/types.js');
}
